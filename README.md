1) توصيف الحالة :
اللعبة عبارة عن رقعة مربعة الشكل (n x n  ) مكونة من ثلاث أنواع من الخلايا :
   1 – خلايا هدف gCell 
   2 – خلايا عادية nCell 
   3 – خلايا جدار bCell   أي لا يمكن وضع حجر فيه او التحرك عليها 

وتحتوي الرقعة على نوعين من الأحجار :
   1 – قطعة معدنية iron  
   2 – مغناطيس وله نوعان (قد تحوي النوعان معاً) :
            1 – سالب لونه بنفسجي وسنرمز له بالرمز N يقوم بتنفير القطع
            2 – موجب لونه احمر و سنرمز له بالرمز B يقوم بجذب القطع

وعندما يتم نقل المغناطيس الى الخلايا الفارغة ( nCell or gCell  ) يقوم بالتأثير على الأحجار المحيطة به افقياً و عمودياً حسب نوعه  .

2) الحالة البدائية :
تم تمثيل كل مرحلة من المراحل بحد ذاتها في الكلاس Game  ( حيث تم بناء 25 مرحلة منفصلة ) ويتكون من :
عدد النقلات السمموحة في المرحلة 
ورقم المرحلة أي ال level of game 
الرقعة الخاصة بالمرحلة Gird 
حيث ال Grid  عبارة عن اوبجيكت من  كلاس منفصل بنفس الاسمو يرمز الى الرقعة ويتكون من :
ابعاد هذه الرقعة و عدد النقلات المسموحة و grid المكون من شبكة من الخلايا العادية nCell 
حيث ان الخلايا بداية تكون عادية وعند بناء الرقعة يتغير نوعها 

وتم تمثيل كل خلية بكلاس ال CELL  ويتكون من :
  ال name  ويرمز الى نوع الخلية : nCell , gCell, bCell 
  ال empty ويرمز الى ان الخلية فارغة او لا :  true or false
  ال contain ويرمز الى ماذا تحتوي الخلية : iron or magnet( N or S )

وتم تمثيل كل حجر بكلاس ال ٍSTONE  ويتكون من :
  ال s_Type  و يرمز الى نوع الحجر :  iron or magnet
  ال m_Type و يرمز الى نوع المغناطيس : N or S or None 
وبناء على البنية السابقة يكون لدينا رقعة مجهزة بمغناطيس او اثنين و قطع معدنية وخلايا هدف .

3) العمليات الإجرائية :  
في بداية اللعبة يقوم اللاعب بختيار المغناطيس المراد تحريكه ويدخل الاحداثيات الجديدة وهنا يستدعى تابع ال : move_magnet(magnet,next_x,next_y)   هذا التابع يقوم بتحريك المغناطيس الى الخلية الجديدة واغراغ مكان المغناطيس السابق وذلك باستخدام تابيعن :
  1 – put_stone(x,y,magnet)  لوضع المغناطيس في الخلية الجديدة 
  2 – remove_stone()  لحذف الحجر من الخلية 
ثم يقوم بالتاثير على الأحجار المحيطة وذلك حسب نوع المغناطيس , اذا كان من النوع S يستدعي التابع : move_stones_around_for_s(new_x,new_y)  فيقوم باذاحة القطع خطوة باتجاه المغناطيس اذا كانت الحركة ممكنة 
واذا كان نوعه المغناطيس N  يستدعي التابع : move_stones_around_for_n(new_x,new_y)  فيقوم بازاحة القطع بعيدا عن المغناطيس خطوة واحدة اذا كانت الحركة ممكنة 

ثم يستدعي تابع ال check_win()  للتحقق من الفوز (امتلاء جميع الخلايا الهدف بالاحجار ) وتابع  check_lose()   للتحقق من الخسارة (عدد النقلات المسموحة اصبح يساوي الصفر ) 
ويتم ذلك في كل مرة يقوم اللاعب بتحريك مغناطيس في اللعبة الى ان تنتهي اللعبة وهنا نكون قد وصلنا الى  4) الحالة النهائية 
أي اما انتهاء الخطوات ويعني الخسارة او امتلاء جميع الخلايا الهدف ويعني الفوز .

الى هنا نكون قد انتهينا من الجزء الأول من اللعبة أي اللاعب هو من يقوم باللعب , الان سننتقل الى الجزء الثاني وهوة قيام الكود بلعب اللعبة وحلها بناء على خوارزميتي ال DFS and BFS  :
اولاً: فضاء الحالات
فضاء الحالات هو مجموعة كل الحالات الممكنة التي يمكن أن توجد في اللعبة في أي وقت بناءً على ترتيب الحركات التي تم اتخاذها. كل حالة تمثل تراكبًا معينًا للحجارة في الشبكة (Grid) ومواقع المغناطيسات، بالإضافة إلى عدد الحركات المتبقية في اللعبة.
ويتضمن:
الشبكة الحالية (Grid): تمثل الشبكة الحالية للحالة، التي تحتوي على ترتيب كل الخلايا والمحتويات الخاصة بها (خلايا فارغة، مغناطيسات، حجارة).
المغناطيسات وحركاتها: كل مغناطيس في الشبكة يمكن أن يتحرك إلى خلايا مختلفة، ويؤثر على الحجارة في الاتجاهات الأربعة (أعلى، أسفل، يسار، يمين) حسب نوع المغناطيس (شمالي أو جنوبي).
الحجارة: تمثل الحجارة الموجودة في الخلايا، والتي تتحرك بناءً على تأثير المغناطيسات.
عدد الحركات المتبقية: يتغير عدد الحركات المتبقية في كل خطوة وفقًا لعدد الحركات المتاحة في اللعبة.
1. بنية المعطيات المستخدمة لتحقيق خوارزمية DFS :
1.1 الـ Grid (الرقعة):
الرقعة هي عبارة عن مصفوفة من الخلايا (Cells) التي تمثل اللوحة الخاصة باللعبة. كل خلية يمكن أن تحتوي على حجر (Stone) أو تكون فارغة. ,و تحتوي بعض الخلايا على مغناطيسات (Magnets) إما من النوع "N" (سالب) أو "S" (موجب). بعض الخلايا تكون هدفًا ("gCell") يجب أن يملأها المغناطيس في النهاية.

1.2 الـ Stack  لتمثيل البحث:
ال Stack هو الهيكل الأساسي المستخدم في خوارزمية البحث بالعمق (DFS). في كل خطوة، يتم تخزين حالتين على ال Stack  :
اللوحة الحالية (current_board): وهي تمثل حالة الرقعة بعد كل خطوة.
المسار الحالي (path): وهو قائمة من الحركات (moves) التي تم اتخاذها من البداية للوصول إلى الوضع الحالي.

1.3 الـ visited = set () (المجموعة) لتمثيل الحالات التي تم زيارتها:
يتم استخدام مجموعة visited لحفظ الحالات التي تمت زيارتها بالفعل لتجنب تكرار الحركات والبحث في نفس الحالة عدة مرات. يتم تمثيل الحالة باستخدام سلسلة من القيم حيث يحتوي كل عنصر على نوع كل حجر في الخلايا.
2. آلية الحل في الخوارزمية خطوة بخطوة : 
الخطوة الأولى: البداية وإعداد البيانات
تبدأ الخوارزمية بتهيئة ال Stack الذي يحتوي على الحالة الأولية للعبة. يتم حفظ حالة اللعبة الحالية في current_board ويتم تعقب الحركات التي تم اتخاذها في path. كما يتم استخدام مجموعة visited لحفظ الحالات التي تم زيارتها لتجنب البحث في نفس الحالة مرتين.
الخطوة الثانية: التحقق من الفوز
في كل خطوة، يتحقق البرنامج مما إذا كانت اللعبة قد انتهت (أي تم ملء الخلايا الهدف "gCell" بالحجارة المطلوبة) باستخدام الدالة check_win ()  إذا تم الوصول إلى حالة فوز، يتم عرض الحل (الحركات التي تم اتخاذها للوصول إلى الوضع النهائي).

الخطوة الثالثة: البحث عن تحركات المغناطيس
يتم النظر في جميع الخلايا التي تحتوي على مغناطيسات (من النوع "N" أو "S") في شبكة اللعبة. يتم التحقق من كل اتجاه (فوق، تحت، يسار، يمين) حيث يمكن للمغناطيس أن يتحرك. إذا كان بإمكانه التحرك إلى خلية فارغة أو خلية هدف ("gCell")، يتم إجراء الحركة.

الخطوة الرابعة: تحديث الحالة
بعد كل حركة، يتم تحديث حالة اللعبة باستخدام move_stone_for_al() التي تحرك الاحجار إلى الخلية الجديدة. كما يتم تحريك الحجارة المحيطة بناءً على نوع المغناطيس. إذا كان المغناطيس من النوع "N" (سالب)، فإنه يدفع الحجارة المحيطة للأمام، بينما إذا كان من النوع "S" (موجب)، فإنه يسحب الحجارة المحيطة.
الخطوة الخامسة: التكرار
تستمر الخوارزمية في البحث عن حركات جديدة باستخدام DFS  حتى تجد الحل أو تنتهي الحركات المتاحة. في كل مرة يتم فيها زيارة حالة جديدة، يتم إضافة الحالة إلى المكدس ويتم تتبع الحركات في path.

الخطوة السادسة: التوقف
عندما يتم الوصول إلى حالة فوز (أي تم ملء جميع الخلايا الهدف بالحجارة المناسبة)، يتم إيقاف البحث ويتم طباعة الحركات التي تم اتخاذها لحل اللعبة. إذا تم استنفاد الحركات المتاحة دون الوصول إلى الفوز، يتم طباعة "لا يوجد حل".
3. الحل:
بناءً على الخوارزمية الموضحة، يتم تحريك المغناطيسات في الشبكة حسب نوع المغناطيس لتأثير على الحجارة المحيطة. العملية تتمثل في:
تحريك المغناطيسات: عند تحريك المغناطيس (سواء كان من النوع "N" أو "S")، تتأثر الحجارة المحيطة بناءً على نوع المغناطيس. إذا كان المغناطيس من النوع "N"، فإنه ينفر الحجارة ويجذبها للأمام، وإذا كان من النوع "S"، فإنه يجذب الحجارة نحو الخلية التي يوجد فيها.
التحقق من الفوز: في كل مرة يتم فيها إجراء حركة، يتم التحقق مما إذا كانت جميع الخلايا الهدف ("gCell") قد امتلأت.
التحقق من التكرار: يتم تجنب تكرار نفس الحركات باستخدام مجموعة visited، مما يساعد في تجنب حالة لا نهائية من البحث.
ومن اجل خوارزمية ال BFS  :
1. بنية المعطيات المستخدمة لتحقيق خوارزمية BFS :
حالة اللعبة:
الـ Game: تحتوي على الـ grid الذي يمثل حالة اللعبة. كما أنها تتضمن حركات المغناطيس وتحقق الشروط (مثل الفوز أو الخسارة).
 (Serialized State): تمثل حالة اللعبة بشكل قابل للمقارنة باستخدام tuple من الخلايا التي تحتوي على محتوياتها. تُستخدم هذه الحالة لتتبع الحركات السابقة والتحقق من أن الخوارزمية لا تعود إلى حالات سابقة.
الـ Queue و Visited:
الـ Queue : تُستخدم لتخزين الحالات التي يجب معالجتها (أي كل رقعة والطرق التي تم الوصول إليها) أثناء تنفيذ الخوارزمية. يُضاف إلى الطابور كل حالة جديدة يتم اكتشافها، مع تتبع الحركات التي أدت إليها.

الـ Visited: هي مجموعة (set) تُستخدم لتخزين الحالات التي تم زيارتها بالفعل لتجنب العودة إلى نفس الحالة.
2. آلية الحل في الخوارزمية خطوة بخطوة:

التحضير للبحث (Initialize)
 (Queue): تبدأ الخوارزمية بإضافة الحالة الأولية للعبة (الرقعة الالولية) إلى Queue مع مسار فارغ.
مجموعات الحالات المزارة (Visited): يتم تهيئة مجموعة فارغة لتخزين الحالات التي تم زيارتها حتى لا تتكرر الحركات.
بداية البحث (BFS Loop)
إزالة الحالة من Queue: تبدأ الخوارزمية بمراجعة أول حالة في Queue (حالة الرقعة الحالية) وتحليلها.
